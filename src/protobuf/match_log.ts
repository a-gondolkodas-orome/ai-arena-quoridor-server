// @generated by protobuf-ts 2.9.1 with parameter ts_nocheck,long_type_number
// @generated from protobuf file "match_log.proto" (syntax proto3)
// tslint:disable
// @ts-nocheck
//
// This file must be kept in sync between
// https://github.com/Kristofy/Quoridor/blob/main/src/protobuf/match_log.proto and
// https://github.com/Kristofy/quoridor-visualizer/tree/master/projects/quoridor-visualizer/src/lib/protobuf/match_log.proto
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message Match
 */
export interface Match {
  /**
   * @generated from protobuf field: Init init = 1;
   */
  init?: Init;
  /**
   * @generated from protobuf field: repeated Tick ticks = 2;
   */
  ticks: Tick[];
}
/**
 * @generated from protobuf message Init
 */
export interface Init {
  /**
   * @generated from protobuf field: repeated Player players = 1;
   */
  players: Player[];
  /**
   * @generated from protobuf field: int32 board_size = 2;
   */
  boardSize: number;
  /**
   * @generated from protobuf field: int32 num_of_walls = 3;
   */
  numOfWalls: number;
}
/**
 * @generated from protobuf message Player
 */
export interface Player {
  /**
   * @generated from protobuf field: string id = 1;
   */
  id: string;
  /**
   * @generated from protobuf field: int32 index = 2;
   */
  index: number;
  /**
   * @generated from protobuf field: string name = 3;
   */
  name: string;
}
/**
 * @generated from protobuf message Tick
 */
export interface Tick {
  /**
   * @generated from protobuf field: int32 current_player = 1;
   */
  currentPlayer: number;
  /**
   * @generated from protobuf field: repeated PawnPos pawn_pos = 2;
   */
  pawnPos: PawnPos[];
  /**
   * @generated from protobuf field: repeated Wall walls = 3;
   */
  walls: Wall[];
  /**
   * @generated from protobuf field: repeated int32 owned_walls = 4;
   */
  ownedWalls: number[];
  /**
   * @generated from protobuf oneof: action
   */
  action:
    | {
        oneofKind: "start";
        /**
         * @generated from protobuf field: bool start = 5;
         */
        start: boolean;
      }
    | {
        oneofKind: "move";
        /**
         * @generated from protobuf field: MoveAction move = 6;
         */
        move: MoveAction;
      }
    | {
        oneofKind: "place";
        /**
         * @generated from protobuf field: PlaceAction place = 7;
         */
        place: PlaceAction;
      }
    | {
        oneofKind: "stuck";
        /**
         * @generated from protobuf field: bool stuck = 8;
         */
        stuck: boolean;
      }
    | {
        oneofKind: undefined;
      };
  /**
   * @generated from protobuf field: repeated Bot bots = 9;
   */
  bots: Bot[];
}
/**
 * @generated from protobuf message PawnPos
 */
export interface PawnPos {
  /**
   * @generated from protobuf field: int32 x = 1;
   */
  x: number;
  /**
   * @generated from protobuf field: int32 y = 2;
   */
  y: number;
}
/**
 * @generated from protobuf message Wall
 */
export interface Wall {
  /**
   * @generated from protobuf field: int32 x = 1;
   */
  x: number;
  /**
   * @generated from protobuf field: int32 y = 2;
   */
  y: number;
  /**
   * @generated from protobuf field: int32 is_vertical = 3;
   */
  isVertical: number;
  /**
   * @generated from protobuf field: int32 who = 4;
   */
  who: number;
}
/**
 * @generated from protobuf message MoveAction
 */
export interface MoveAction {
  /**
   * @generated from protobuf field: int32 x = 1;
   */
  x: number;
  /**
   * @generated from protobuf field: int32 y = 2;
   */
  y: number;
}
/**
 * @generated from protobuf message PlaceAction
 */
export interface PlaceAction {
  /**
   * @generated from protobuf field: int32 x = 1;
   */
  x: number;
  /**
   * @generated from protobuf field: int32 y = 2;
   */
  y: number;
  /**
   * @generated from protobuf field: int32 is_vertical = 3;
   */
  isVertical: number;
}
/**
 * @generated from protobuf message Bot
 */
export interface Bot {
  /**
   * @generated from protobuf field: string id = 1;
   */
  id: string;
  /**
   * @generated from protobuf field: int32 index = 2;
   */
  index: number;
  /**
   * @generated from protobuf field: repeated BotMessage received = 3;
   */
  received: BotMessage[];
  /**
   * @generated from protobuf field: repeated BotMessage sent = 4;
   */
  sent: BotMessage[];
  /**
   * @generated from protobuf field: optional string error = 5;
   */
  error?: string;
  /**
   * @generated from protobuf field: optional string bot_log = 6;
   */
  botLog?: string;
  /**
   * @generated from protobuf field: int32 distance = 7;
   */
  distance: number;
  /**
   * @generated from protobuf field: optional bool offline = 8;
   */
  offline?: boolean;
}
/**
 * @generated from protobuf message BotMessage
 */
export interface BotMessage {
  /**
   * @generated from protobuf field: string message = 1;
   */
  message: string;
  /**
   * @generated from protobuf field: uint64 timestamp = 2;
   */
  timestamp: number;
}
// @generated message type with reflection information, may provide speed optimized methods
class Match$Type extends MessageType<Match> {
  constructor() {
    super("Match", [
      { no: 1, name: "init", kind: "message", T: () => Init },
      { no: 2, name: "ticks", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Tick },
    ]);
  }
  create(value?: PartialMessage<Match>): Match {
    const message = { ticks: [] };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== undefined) reflectionMergePartial<Match>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Match,
  ): Match {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* Init init */ 1:
          message.init = Init.internalBinaryRead(reader, reader.uint32(), options, message.init);
          break;
        case /* repeated Tick ticks */ 2:
          message.ticks.push(Tick.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: Match,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* Init init = 1; */
    if (message.init)
      Init.internalBinaryWrite(
        message.init,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated Tick ticks = 2; */
    for (let i = 0; i < message.ticks.length; i++)
      Tick.internalBinaryWrite(
        message.ticks[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Match
 */
export const Match = new Match$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Init$Type extends MessageType<Init> {
  constructor() {
    super("Init", [
      { no: 1, name: "players", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Player },
      { no: 2, name: "board_size", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 3, name: "num_of_walls", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
    ]);
  }
  create(value?: PartialMessage<Init>): Init {
    const message = { players: [], boardSize: 0, numOfWalls: 0 };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== undefined) reflectionMergePartial<Init>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Init,
  ): Init {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated Player players */ 1:
          message.players.push(Player.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* int32 board_size */ 2:
          message.boardSize = reader.int32();
          break;
        case /* int32 num_of_walls */ 3:
          message.numOfWalls = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: Init,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated Player players = 1; */
    for (let i = 0; i < message.players.length; i++)
      Player.internalBinaryWrite(
        message.players[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* int32 board_size = 2; */
    if (message.boardSize !== 0) writer.tag(2, WireType.Varint).int32(message.boardSize);
    /* int32 num_of_walls = 3; */
    if (message.numOfWalls !== 0) writer.tag(3, WireType.Varint).int32(message.numOfWalls);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Init
 */
export const Init = new Init$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Player$Type extends MessageType<Player> {
  constructor() {
    super("Player", [
      { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "index", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<Player>): Player {
    const message = { id: "", index: 0, name: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== undefined) reflectionMergePartial<Player>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Player,
  ): Player {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */ 1:
          message.id = reader.string();
          break;
        case /* int32 index */ 2:
          message.index = reader.int32();
          break;
        case /* string name */ 3:
          message.name = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: Player,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string id = 1; */
    if (message.id !== "") writer.tag(1, WireType.LengthDelimited).string(message.id);
    /* int32 index = 2; */
    if (message.index !== 0) writer.tag(2, WireType.Varint).int32(message.index);
    /* string name = 3; */
    if (message.name !== "") writer.tag(3, WireType.LengthDelimited).string(message.name);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Player
 */
export const Player = new Player$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Tick$Type extends MessageType<Tick> {
  constructor() {
    super("Tick", [
      { no: 1, name: "current_player", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      {
        no: 2,
        name: "pawn_pos",
        kind: "message",
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => PawnPos,
      },
      { no: 3, name: "walls", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Wall },
      {
        no: 4,
        name: "owned_walls",
        kind: "scalar",
        repeat: 1 /*RepeatType.PACKED*/,
        T: 5 /*ScalarType.INT32*/,
      },
      { no: 5, name: "start", kind: "scalar", oneof: "action", T: 8 /*ScalarType.BOOL*/ },
      { no: 6, name: "move", kind: "message", oneof: "action", T: () => MoveAction },
      { no: 7, name: "place", kind: "message", oneof: "action", T: () => PlaceAction },
      { no: 8, name: "stuck", kind: "scalar", oneof: "action", T: 8 /*ScalarType.BOOL*/ },
      { no: 9, name: "bots", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Bot },
    ]);
  }
  create(value?: PartialMessage<Tick>): Tick {
    const message = {
      currentPlayer: 0,
      pawnPos: [],
      walls: [],
      ownedWalls: [],
      action: { oneofKind: undefined },
      bots: [],
    };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== undefined) reflectionMergePartial<Tick>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Tick,
  ): Tick {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int32 current_player */ 1:
          message.currentPlayer = reader.int32();
          break;
        case /* repeated PawnPos pawn_pos */ 2:
          message.pawnPos.push(PawnPos.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated Wall walls */ 3:
          message.walls.push(Wall.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated int32 owned_walls */ 4:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.ownedWalls.push(reader.int32());
          else message.ownedWalls.push(reader.int32());
          break;
        case /* bool start */ 5:
          message.action = {
            oneofKind: "start",
            start: reader.bool(),
          };
          break;
        case /* MoveAction move */ 6:
          message.action = {
            oneofKind: "move",
            move: MoveAction.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.action as any).move,
            ),
          };
          break;
        case /* PlaceAction place */ 7:
          message.action = {
            oneofKind: "place",
            place: PlaceAction.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.action as any).place,
            ),
          };
          break;
        case /* bool stuck */ 8:
          message.action = {
            oneofKind: "stuck",
            stuck: reader.bool(),
          };
          break;
        case /* repeated Bot bots */ 9:
          message.bots.push(Bot.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: Tick,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* int32 current_player = 1; */
    if (message.currentPlayer !== 0) writer.tag(1, WireType.Varint).int32(message.currentPlayer);
    /* repeated PawnPos pawn_pos = 2; */
    for (let i = 0; i < message.pawnPos.length; i++)
      PawnPos.internalBinaryWrite(
        message.pawnPos[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated Wall walls = 3; */
    for (let i = 0; i < message.walls.length; i++)
      Wall.internalBinaryWrite(
        message.walls[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated int32 owned_walls = 4; */
    if (message.ownedWalls.length) {
      writer.tag(4, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.ownedWalls.length; i++) writer.int32(message.ownedWalls[i]);
      writer.join();
    }
    /* bool start = 5; */
    if (message.action.oneofKind === "start")
      writer.tag(5, WireType.Varint).bool(message.action.start);
    /* MoveAction move = 6; */
    if (message.action.oneofKind === "move")
      MoveAction.internalBinaryWrite(
        message.action.move,
        writer.tag(6, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* PlaceAction place = 7; */
    if (message.action.oneofKind === "place")
      PlaceAction.internalBinaryWrite(
        message.action.place,
        writer.tag(7, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* bool stuck = 8; */
    if (message.action.oneofKind === "stuck")
      writer.tag(8, WireType.Varint).bool(message.action.stuck);
    /* repeated Bot bots = 9; */
    for (let i = 0; i < message.bots.length; i++)
      Bot.internalBinaryWrite(
        message.bots[i],
        writer.tag(9, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Tick
 */
export const Tick = new Tick$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PawnPos$Type extends MessageType<PawnPos> {
  constructor() {
    super("PawnPos", [
      { no: 1, name: "x", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 2, name: "y", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
    ]);
  }
  create(value?: PartialMessage<PawnPos>): PawnPos {
    const message = { x: 0, y: 0 };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== undefined) reflectionMergePartial<PawnPos>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: PawnPos,
  ): PawnPos {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int32 x */ 1:
          message.x = reader.int32();
          break;
        case /* int32 y */ 2:
          message.y = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: PawnPos,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* int32 x = 1; */
    if (message.x !== 0) writer.tag(1, WireType.Varint).int32(message.x);
    /* int32 y = 2; */
    if (message.y !== 0) writer.tag(2, WireType.Varint).int32(message.y);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message PawnPos
 */
export const PawnPos = new PawnPos$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Wall$Type extends MessageType<Wall> {
  constructor() {
    super("Wall", [
      { no: 1, name: "x", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 2, name: "y", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 3, name: "is_vertical", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 4, name: "who", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
    ]);
  }
  create(value?: PartialMessage<Wall>): Wall {
    const message = { x: 0, y: 0, isVertical: 0, who: 0 };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== undefined) reflectionMergePartial<Wall>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Wall,
  ): Wall {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int32 x */ 1:
          message.x = reader.int32();
          break;
        case /* int32 y */ 2:
          message.y = reader.int32();
          break;
        case /* int32 is_vertical */ 3:
          message.isVertical = reader.int32();
          break;
        case /* int32 who */ 4:
          message.who = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: Wall,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* int32 x = 1; */
    if (message.x !== 0) writer.tag(1, WireType.Varint).int32(message.x);
    /* int32 y = 2; */
    if (message.y !== 0) writer.tag(2, WireType.Varint).int32(message.y);
    /* int32 is_vertical = 3; */
    if (message.isVertical !== 0) writer.tag(3, WireType.Varint).int32(message.isVertical);
    /* int32 who = 4; */
    if (message.who !== 0) writer.tag(4, WireType.Varint).int32(message.who);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Wall
 */
export const Wall = new Wall$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MoveAction$Type extends MessageType<MoveAction> {
  constructor() {
    super("MoveAction", [
      { no: 1, name: "x", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 2, name: "y", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
    ]);
  }
  create(value?: PartialMessage<MoveAction>): MoveAction {
    const message = { x: 0, y: 0 };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== undefined) reflectionMergePartial<MoveAction>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: MoveAction,
  ): MoveAction {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int32 x */ 1:
          message.x = reader.int32();
          break;
        case /* int32 y */ 2:
          message.y = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: MoveAction,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* int32 x = 1; */
    if (message.x !== 0) writer.tag(1, WireType.Varint).int32(message.x);
    /* int32 y = 2; */
    if (message.y !== 0) writer.tag(2, WireType.Varint).int32(message.y);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message MoveAction
 */
export const MoveAction = new MoveAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlaceAction$Type extends MessageType<PlaceAction> {
  constructor() {
    super("PlaceAction", [
      { no: 1, name: "x", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 2, name: "y", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 3, name: "is_vertical", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
    ]);
  }
  create(value?: PartialMessage<PlaceAction>): PlaceAction {
    const message = { x: 0, y: 0, isVertical: 0 };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== undefined) reflectionMergePartial<PlaceAction>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: PlaceAction,
  ): PlaceAction {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int32 x */ 1:
          message.x = reader.int32();
          break;
        case /* int32 y */ 2:
          message.y = reader.int32();
          break;
        case /* int32 is_vertical */ 3:
          message.isVertical = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: PlaceAction,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* int32 x = 1; */
    if (message.x !== 0) writer.tag(1, WireType.Varint).int32(message.x);
    /* int32 y = 2; */
    if (message.y !== 0) writer.tag(2, WireType.Varint).int32(message.y);
    /* int32 is_vertical = 3; */
    if (message.isVertical !== 0) writer.tag(3, WireType.Varint).int32(message.isVertical);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message PlaceAction
 */
export const PlaceAction = new PlaceAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Bot$Type extends MessageType<Bot> {
  constructor() {
    super("Bot", [
      { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "index", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      {
        no: 3,
        name: "received",
        kind: "message",
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => BotMessage,
      },
      {
        no: 4,
        name: "sent",
        kind: "message",
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => BotMessage,
      },
      { no: 5, name: "error", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 6, name: "bot_log", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 7, name: "distance", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 8, name: "offline", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
    ]);
  }
  create(value?: PartialMessage<Bot>): Bot {
    const message = { id: "", index: 0, received: [], sent: [], distance: 0 };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== undefined) reflectionMergePartial<Bot>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Bot,
  ): Bot {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */ 1:
          message.id = reader.string();
          break;
        case /* int32 index */ 2:
          message.index = reader.int32();
          break;
        case /* repeated BotMessage received */ 3:
          message.received.push(BotMessage.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated BotMessage sent */ 4:
          message.sent.push(BotMessage.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* optional string error */ 5:
          message.error = reader.string();
          break;
        case /* optional string bot_log */ 6:
          message.botLog = reader.string();
          break;
        case /* int32 distance */ 7:
          message.distance = reader.int32();
          break;
        case /* optional bool offline */ 8:
          message.offline = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: Bot,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string id = 1; */
    if (message.id !== "") writer.tag(1, WireType.LengthDelimited).string(message.id);
    /* int32 index = 2; */
    if (message.index !== 0) writer.tag(2, WireType.Varint).int32(message.index);
    /* repeated BotMessage received = 3; */
    for (let i = 0; i < message.received.length; i++)
      BotMessage.internalBinaryWrite(
        message.received[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated BotMessage sent = 4; */
    for (let i = 0; i < message.sent.length; i++)
      BotMessage.internalBinaryWrite(
        message.sent[i],
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional string error = 5; */
    if (message.error !== undefined) writer.tag(5, WireType.LengthDelimited).string(message.error);
    /* optional string bot_log = 6; */
    if (message.botLog !== undefined)
      writer.tag(6, WireType.LengthDelimited).string(message.botLog);
    /* int32 distance = 7; */
    if (message.distance !== 0) writer.tag(7, WireType.Varint).int32(message.distance);
    /* optional bool offline = 8; */
    if (message.offline !== undefined) writer.tag(8, WireType.Varint).bool(message.offline);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message Bot
 */
export const Bot = new Bot$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BotMessage$Type extends MessageType<BotMessage> {
  constructor() {
    super("BotMessage", [
      { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 2,
        name: "timestamp",
        kind: "scalar",
        T: 4 /*ScalarType.UINT64*/,
        L: 2 /*LongType.NUMBER*/,
      },
    ]);
  }
  create(value?: PartialMessage<BotMessage>): BotMessage {
    const message = { message: "", timestamp: 0 };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== undefined) reflectionMergePartial<BotMessage>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BotMessage,
  ): BotMessage {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string message */ 1:
          message.message = reader.string();
          break;
        case /* uint64 timestamp */ 2:
          message.timestamp = reader.uint64().toNumber();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BotMessage,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string message = 1; */
    if (message.message !== "") writer.tag(1, WireType.LengthDelimited).string(message.message);
    /* uint64 timestamp = 2; */
    if (message.timestamp !== 0) writer.tag(2, WireType.Varint).uint64(message.timestamp);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message BotMessage
 */
export const BotMessage = new BotMessage$Type();
